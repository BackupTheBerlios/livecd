#!/usr/bin/perl
#
# LiveCD install to HDD script
# Copyright (C) 2003, Jaco Greeff <jaco@linuxminicd.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# The latest version of this script can be found at http://livecd.berlios.de
#
# $Id: livecd-install,v 1.5 2003/11/21 20:19:05 jaco Exp $
#

use lib qw(/usr/lib/libDrakX);

use bootloader;
use fs;

# our distro
my $distro = qx(cat /etc/redhat-release | awk '{ print \$1 }');
chomp($distro);

# the dialog we are using (kdialog doen't have progress :(
my $dlg    = "zenity";

# name => [ lang 1, lang 2, lang 3, ... ]
my %str = (
	# error strings
	'FATAL_ERROR_TIT'  => [ "Fatal Error",
				"Fatale Fout" ],
	'WARN_ERROR_TIT'   => [ "Warning",
				"Waarskuwing" ],

	# welcome screen
	'WELCOME_TIT'      => [ "Welcome",
				"Welkom" ],
	'WELCOME_STR'      => [ "Welcome to the $distro LiveCD installation program.\n\nThis program will guide you through the process\nof installing the $distro LiveCD to hard disk.",
				"Welkom by die $distro LiveCD installasie program.\n\nHierdie program sal jou deur die stappe neem\nom die $distro LiveCD op jou harde skyf te installeer." ],
	'WARNCORR_STR'     => [ "This is BETA quality software and might have\nadverse (unintended) side effects. Use with care!\n\nThis program is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.",
				"Hierdie is BETA kwaliteit sagteware en mag\nnegatiewe (onbeplande) newe-effekte he. Gebruik dit versigtig!\n\n\"This program is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\"" ],

	# partition selection screen
	'PROGSEL_TIT'      => [ "Mount Point Selection",
				"Skryf Punt Seleksie" ],
	'PROGSEL_STR'      => [ "",
				"" ],
	'PROGSEL_COL'      => [ "Program",
				"Program" ],
	'PROGSEL_DD'       => [ "Launch the DiskDrake partitioning tool",
				"Loop die DiskDrake skyf verdeler" ],
	'PROGSEL_INST'     => [ "Launch the LiveCD installer",
				"Loop die LiveCD installasie program" ],

	# install screens
	'INSTPART_TIT'     => [ "Destination Partition",
				"Installasie Bestemming" ],
	'INSTPART_PART'    => [ "Partition",
				"Partisie" ],
	'INSTPART_SIZE'    => [ "Size",
				"Grootte" ],
	'INSTPART_TYPE'    => [ "Type",
				"Tipe" ],
	'INSTPART_WARN'    => [ "You are about to install $distro LiveCD to:",
				"Jy sal nou $distro LiveCD installeer na:" ],

	# progress dlg
	'INSTPROG_TIT'     => [ "Installing",
				"Installasie" ],
	'INSTPROG_STR'     => [ "Installing $distro LiveCD to",
				"Installasie van $distro LiveCD na" ]
);

# languages for %str (numbers represent positions)
my $LANG_EN   = 0;
my $LANG_AF   = 1;
# add any extra language here
my $lang      = $LANG_EN;

# allowed devices
my %devs = ();

my %fstypes = (83 => 'ext2', 183 => 'reiserfs', 283 => 'xfs', 383 => 'jfs', 483 => 'ext3');

# reads our partitions
sub read_parts {
	my @lines = qx(/sbin/fdisk -l | /bin/grep ^/dev | /bin/grep -v Extended);
	foreach my $line (@lines) {
		chomp($line);
		my $boot = ($line =~ /\s\*\s/) ? 1 : 0;
		$line =~ s/\s\*\s/ /;
		my ($dev, $start, $end, $blocks, $id, $type) = split(/\s+/, $line, 6);
		$blocks =~ s/\+//;
		if ($id eq 83 || $id eq 183 || $id eq 283 || $id eq 383 || $id eq 483) {
			$devs{$dev}{'boot'} = $boot;
			$devs{$dev}{'size'} = int($blocks/1024);
			$devs{$dev}{'type'} = $type;
			$devs{$dev}{'id'} = $id;
		}
	}
}

# copy a single dit, decending on it's subdirs
sub copy_dir {
	my ($file, $root, $dir, $mnt, $prog, $inc) = @_;

	my $tmp = $prog;
	qx(mkdir -p "$mnt/$dir" ; chown --reference="$root/$dir" "$mnt/$dir" ; chmod --reference="$root/$dir" "$mnt/$dir") unless ($dir eq "/");
	qx(cp -dp "$root/$dir/" "$mnt/$dir" 2>/dev/null);

	my @roots = qx(find "$root/$dir" -type d -maxdepth 1 | grep -v "^$root/$dir\$" | sed -e \'s,^$root/,,\' | grep -v ^/dev | grep -v ^/proc);
	if (scalar(@roots)) {
		my $i = $inc/scalar(@roots);
		foreach my $r (@roots) {
			chomp($r);
			copy_dir($file, $root, $r, $mnt, $prog, $i); # from $prog -> $prog+$i
			$prog = $prog + $i;
		}
	}
	$prog = $tmp + $inc;
	print $file "$prog\n";
}

# copy
sub copy_to {
	my ($dev, $mnt) = @_;
	my $initrd = "/initrd/loopfs";
	my $file = undef;
	my $prog = 0;
	my $cancel = 0;

	open($file, "|$dlg --progress --width 450 --title \"".$str{'INSTPROG_TIT'}[$lang]."\" --text \"".$str{'INSTPROG_STR'}[$lang]." $dev\" --percentage 0 --auto-close");

	# whack everything on new root
	my @root = qx(ls -a1 $mnt | grep -v lost+found | grep -v ^./ | grep -v ^../);
	if (scalar(@root)) {
		my $inc = 5/(scalar(@root)); # from 0 to 5
		foreach my $r (@root) {
			qx(rm -rf $mnt/$r) unless ($cancel);
			$prog = $prog + $inc;
			print $file "$prog\n" or $cancel = 1;
		}
	}
	print $file "$prog\n" or $cancel = 1;

	# find all the root dirs on the current root
	copy_dir($file, $initrd, "/", $mnt, 5, 90); # from 5 to 95

	# make the rest
	qx(mkdir -p $mnt/dev ; mkdir -p $mnt/proc);
	print $file "96\n";
	qx(mkdir -p $mnt/initrd);
	print $file "97\n";
	qx(mkdir -p $mnt/tmp ; chmod 755 $mnt/tmp);
	print $file "98\n";
	qx(ln -sf ../tmp $mnt/var/tmp);
	print $file "99\n";
	qx(mkdir -p $mnt/var/lock/subsys ; mkdir -p $mnt/var/run);
	print $file "100\n";
	close($file);
}

# create a basic fstab
sub make_fstab {
	my ($dev, $mnt) = @_;
	my @fstab = fs::read_fstab("", "/etc/fstab");
	my $hdds = {};
	fs::add2all_hds($hdds, @fstab);
	fs::write_fstab($hdds, $mnt);
	open FSTAB, '>>', "$mnt/etc/fstab";
	print FSTAB "$dev / ".$fstypes{$devs{$dev}{'id'}}." defaults 0 0\n";
	close FSTAB;
}

# create the lilo.conf
sub make_lilo {
	my ($dev, $mnt) = @_;
}

# do the actual install
sub do_install {
	my $quit = 0;
	while (!$quit) {
		my $list = "";
		$list .= " \"\" $_ ".$devs{$_}{'size'}."MB \"".$devs{$_}{'type'}." (". ($fstypes{$devs{$_}{'id'}}).")\"" foreach (sort keys %devs);
		my $dev = qx($dlg --list --radiolist --width 500 --height 300 --title "$str{'INSTPART_TIT'}[$lang]" --column "" --column "$str{'INSTPART_PART'}[$lang]" --column "$str{'INSTPART_SIZE'}[$lang]" --column "$str{'INSTPART_TYPE'}[$lang]" $list || echo cancel);
		chomp($dev);
		unless ($dev =~ /cancel/ || $dev eq "") {
			my $ret = qx($dlg --warning --title "$str{'WARN_ERROR_TIT'}[$lang]" --text "$str{'INSTPART_WARN'}[$lang]\n$dev ($fstypes{$devs{$dev}{'id'}})" || echo cancel);
			unless ($ret =~ /cancel/) {
				my $mnt = "/tmp/livecd.inst.$$";
				my $type = $fstypes{$devs{$dev}{'id'}};
				qx(mkdir -p $mnt ; umount $dev ; mount -t $type $dev $mnt);
				copy_to($dev, $mnt);
				make_fstab($dev, $mnt);
				make_lilo($dev, $mnt);
				qx(umount $mnt ; rm -rf $mnt);
				exit(0);
			}
		}
		else {
			$quit = 1;
		}
	}
}

# main entry point
MAIN: {
	qx($dlg --info --title "$str{'WELCOME_TIT'}[$lang]" --text "$str{'WELCOME_STR'}[$lang]");
	my $ret = qx($dlg --warning --title "$str{'WARN_ERROR_TIT'}[$lang]" --text "$str{'WARNCORR_STR'}[$lang]" || echo cancel);
	exit(0) if ($ret =~ /cancel/);

	my $quit = 0;
	while (!$quit) {
		my $ret = qx($dlg --list --radiolist --width 300 --height 200 --title "$str{'PROGSEL_TIT'}[$lang]" --column "" --column "$str{'PROGSEL_COL'}[$lang]" '' "$str{'PROGSEL_DD'}[$lang]" '' "$str{'PROGSEL_INST'}[$lang]" || echo quit);
		chomp($ret);
		if ($ret =~ /quit/) {
			exit(0);
		}
		elsif ($ret eq $str{'PROGSEL_DD'}[$lang]) {
			exec("/usr/sbin/diskdrake");
		}
		elsif ($ret eq $str{'PROGSEL_INST'}[$lang]) {
			read_parts;
			do_install;
		}
	}
}
