#!/usr/bin/perl
#
# LiveCD install to HDD script
# Copyright (C) 2003, Jaco Greeff <jaco@linuxminicd.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# The latest version of this script can be found at http://livecd.berlios.de
#
# $Id: livecd-install,v 1.23 2003/11/23 06:37:54 jaco Exp $
#

use lib qw(/usr/lib/libDrakX);

use Getopt::Long;

use interactive;

use common;

use bootloader;
use fs;

use MDK::Common::System;

# my name
my $PROG_NAME = "livecd-install";
my $PROG_VER  = "0.1.0";

# our distro
my $distro = qx(cat /etc/redhat-release | awk '{ print \$1 }');
chomp($distro);

# the dialog we are using (kdialog doen't have progress :(
my $dlg    = "zenity";

# name => [ lang 1, lang 2, lang 3, ... ]
my %str = (
	# error strings
	'FATAL_ERROR_TIT'  => [ "Fatal Error",
				"Fatale Fout" ],
	'WARN_ERROR_TIT'   => [ "Warning",
				"Waarskuwing" ],

	# initial exits
	'INITERR_ROOT'     => [ "You need to be root to run this program",
				"Jy moet administreerder (root) wees om die program te loop" ],
	'INITERR_LIVECD'   => [ "This program can only be run from a $distro LiveCD",
				"Hierdie program kan net van 'n $distro LiveCD geloop word" ],
	'INITERR_ZEN'      => [ "This program needs 'zenity' or 'zenity-qt' to be installed",
				"Hierdie program het 'zenity' of 'zenity-qt' nodig" ],

	# welcome screen
	'WELCOME_TIT'      => [ "Welcome",
				"Welkom" ],
	'WELCOME_STR'      => [ "Welcome to the $distro LiveCD installation program.\n\nThis program will guide you through the process\nof installing the $distro LiveCD to hard disk.",
				"Welkom by die $distro LiveCD installasie program.\n\nHierdie program sal jou deur die stappe neem\nom die $distro LiveCD op jou harde skyf te installeer." ],
	'WARNCORR_STR'     => [ "This is BETA quality software and might have\nadverse (unintended) side effects. Use with care!\n\nThis program is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.",
				"Hierdie is BETA kwaliteit sagteware en mag\nnegatiewe (onbeplande) newe-effekte he. Gebruik dit versigtig!\n\n'This program is distributed in the hope that it will\nbe useful, but WITHOUT ANY WARRANTY;\nwithout even the implied warranty of MERCHANTABILITY\nor FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details'" ],

	# partition selection screen
	'PROGSEL_TIT'      => [ "Mount Point Selection",
				"Skryf Punt Seleksie" ],
	'PROGSEL_STR'      => [ "",
				"" ],
	'PROGSEL_COL'      => [ "Program",
				"Program" ],
	'PROGSEL_DD'       => [ "Launch the DiskDrake partitioning tool",
				"Loop die DiskDrake skyf verdeler" ],
	'PROGSEL_INST'     => [ "Launch the LiveCD installer",
				"Loop die LiveCD installasie program" ],

	# install screens
	'INSTPART_TIT'     => [ "Destination Partition",
				"Installasie Bestemming" ],
	'INSTPART_PART'    => [ "Partition",
				"Partisie" ],
	'INSTPART_SIZE'    => [ "Size",
				"Grootte" ],
	'INSTPART_TYPE'    => [ "Type",
				"Tipe" ],
	'INSTPART_WARN'    => [ "You are about to install $distro LiveCD to:",
				"Jy sal nou $distro LiveCD installeer na:" ],

	# detection dlg
	'DETECT_TIT'       => [ "Disk detection",
				"Skyf vind" ],
	'DETECT_STR'       => [ "Please be patient while detecting attached disks",
				"Wees asseblief geduldig terwyl ons soek vir skywe" ],

	# progress dlg
	'INSTPROG_TIT'     => [ "Installing",
				"Installasie" ],
	'INSTPROG_STR'     => [ "Installing $distro LiveCD to",
				"Installasie van $distro LiveCD na" ],

	# lili
	'LILO_TIT'         => [ "Bootloader configuration",
				"Laaier konfigurasie" ],
	'LILO_MBR_STR'     => [ "Install LILO to master boot record",
				"Installeer LILO na hoof laai rekord" ],
	'LILO_DSK_STR'     => [ "Install LILO to harddisk",
				"Installeer LILO na hardeskyf" ],

	# finished
	'FIN_TIT'          => [ "Installation completed",
				"Installasie voltooi" ],
	'FIN_STR'          => [ "Congratulations, you have completed the install of\n$distro LiveCD to your hard drive. Do you want\nto reboot the system now for the changes to take\neffect?",
				"Geluk, jy het die installasie prosedure vir\n$distro LiveCD voltooi. Wil jy nou die\nstelsel herlaai om die veranderinge te voltooi?" ]
);

# languages for %str (numbers represent positions)
# add any extra translations here
my %langs = (
	'en' => 0,
	'af' => 1,
	'vi' => 2
);
my $lang_str  = undef;
my $lang      = undef;

# allowed devices
my %devs = ();

# reads our partitions
sub read_parts {
	open($file, "|$dlg --progress --width 450 --title \"".$str{'DETECT_TIT'}[$lang]."\" --text \"".$str{'DETECT_STR'}[$lang]." $dev\" --pulsate --auto-close");
	qx(/initrd/usr/sbin/hwdetect --prefix /tmp/livecd.inst.$$ --fdisk >/dev/null);
	foreach my $line (cat_("/tmp/livecd.inst.$$/etc/livecd/hwdetect/mounts.cfg")) {
		chomp($line);
		my ($dev, $info) = split(/=\|/, $line, 2);
		my $devlnk = "/dev/$dev";
		%{$devs{$devlnk}} = map {
			chomp;
			my ($name, $value) = split(/=/, $_, 2);
			print "$dev: $name = [ $value ]\n";
			$name => $value || 1;
		} split(/\|/, $info);
	}
	qx(rm -rf /tmp/livecd.inst.$$);
	print $file "100\n";
	close($file);
}

# copy a single dit, decending on it's subdirs
sub copy_dir {
	my ($file, $root, $dir, $mnt, $prog, $inc) = @_;

	print sprintf("%0.70s ", $dir);
	qx(mkdir -p "$mnt/$dir" ; chown --reference="$root/$dir" "$mnt/$dir" ; chmod --reference="$root/$dir" "$mnt/$dir");
	unless (($dir =~ m|^/lib/dev-state|) || ($dir =~ m|^/proc|) || ($dir =~ m|^/dev|)) {
		qx(cp -dp "$root/$dir/"* "$mnt/$dir" 2>/dev/null);
		qx(cp -dp "$root/$dir/".* "$mnt/$dir" 2>/dev/null);
	}
	print sprintf("\x1B[72G[%6.2f%%]\n", $prog);

	$prog = $prog + $inc;
	print $file "$prog\n";
	$prog;
}

# copy
sub copy_to {
	my ($dev, $mnt) = @_;
	my $initrd = "/initrd/loopfs";
	my $file = undef;
	my $prog = 0;
	my $cancel = 0;

	open($file, "|$dlg --progress --width 450 --title \"".$str{'INSTPROG_TIT'}[$lang]."\" --text \"".$str{'INSTPROG_STR'}[$lang]." $dev\" --percentage 0 --auto-close");

	# whack everything on new root
	my @root = qx(ls -a1 $mnt | grep -v lost+found | grep -v ^./ | grep -v ^../);
	if (scalar(@root)) {
		my $inc = 5/(scalar(@root)); # from 0 to 5
		foreach my $r (@root) {
			qx(rm -rf $mnt/$r) unless ($cancel);
			$prog = $prog + $inc;
			print $file "$prog\n" or $cancel = 1;
		}
	}
	print $file "$prog\n" or $cancel = 1;

	# find all the root dirs on the current root
	my $du = qx(du $initrd -ks | awk '{ print $1 }');
	chomp($du);
	my @dirs = qx(find $initrd -type d | sed -s 's,$initrd,,');
	$prog = 5;
	my $inc = 90/scalar(@dirs); # from 5 to 95
	foreach my $dir (@dirs) {
		chomp($dir);
		$prog = copy_dir($file, $initrd, $dir, $mnt, $prog, $inc);
	}

	# make the rest
	qx(mkdir -p $mnt/dev ; mkdir -p $mnt/proc);
	print $file "96\n";
	qx(mkdir -p $mnt/initrd);
	print $file "97\n";
	qx(mkdir -p $mnt/tmp ; chmod 755 $mnt/tmp);
	print $file "98\n";
	qx(ln -sf ../tmp $mnt/var/tmp);
	print $file "99\n";
	qx(mkdir -p $mnt/var/lock/subsys ; mkdir -p $mnt/var/run);
	print $file "100\n";
	close($file);
}

# create a basic fstab
my %fsopts = (
	'ext2'     => 'defaults',
	'ext3'     => 'defaults',
	'jfs'      => 'defaults',
	'reiserfs' => 'notail,noatime',
	'xfs'      => 'defaults'
);

my %fsnames = (
	'ext2'     => 'Linux native',
	'reiserfs' => 'Journalised FS: ReiserFS',
	'xfs'      => 'Journalised FS: XFS',
	'jfs'      => 'Journalised FS: JFS',
	'ext3'     => 'Journalised FS: ext3'
);

sub make_fstab {
	my ($dev, $mnt) = @_;
	my @fstab = fs::read_fstab("", "/etc/fstab");
	my $hdds = {};
	fs::add2all_hds($hdds, @fstab);
	fs::write_fstab($hdds, $mnt);
	open FSTAB, '>', "$mnt/etc/fstab";
	print FSTAB "\n### entries below this line were automatically added by $PROG_NAME v$PROG_VER\n";
	print FSTAB "\nnone"."\t"."/proc"."\t"."proc"."\t"."defaults"."\t"."0 0";
	print FSTAB "\nnone"."\t"."/dev"."\t"."devfs"."\t"."defaults"."\t"."0 0";
	print FSTAB "\n";
	foreach my $dev (sort keys %devs) {
		my $devpnt = $dev;
		$devpnt =~ s|/dev/||;
		qx(mkdir -p $mnt/mnt/$devpnt 2>/dev/null);
		print FSTAB "\n# ".$devs{$dev}->{info};
		my $entry = "\n";
		$entry .= $devs{$dev}->{devfs}."\t";
		$entry .= $devs{$dev}->{mount}."\t";
		$entry .= $devs{$dev}->{type}."\t";
		my $opt = "";
		$opt .= $devs{$dev}->{opt} if ($devs{$dev}->{opt});
		$opt .= "," if ($devs{$dev}->{opt} && $devs{$dev}->{extopt});
		$opt .= $devs{$dev}->{extopt} if ($devs{$dev}->{extopt});
		$entry .= $opt."\t"."0 0\n";
		print FSTAB $entry;
	}
	close FSTAB;
}

# create the lilo.conf
sub make_lilo {
	my ($dev, $mnt) = @_;
	my $kernel = qx(uname -r);
	chomp($kernel);
	$kernel = "vmlinuz-$kernel";

	my $mbr = $dev;
	$mbr =~ s/[0-9]//;

	my $disk = $dev;
	my $dskstr = $str{'LILO_DSK_STR'}[$lang]." ($disk)";
	my $mbrstr = $str{'LILO_MBR_STR'}[$lang]." ($mbr)";

	my $done = undef;
	while (!defined($done)) {
		my $ret = qx($dlg --list --radiolist --width 300 --height 200 --title "$str{'LILO_TIT'}[$lang]" --column "" --column "" '' "$mbrstr" '' "$dskstr" || echo nolilo);
		chomp($ret);
		if ($ret =~ /nolilo/) {
			$done = 1;
		}
		elsif (($ret eq $dskstr) || ($ret eq $mbrstr)) {
			$done = 1;
			open LILO, '>', "$mnt/etc/lilo.conf";
			my $bootdev = ($ret eq $dskstr) ? $disk : $mbr;
			print LILO "boot=$bootdev
map=/boot/map
default=\"$distro\"
keytable=/boot/us.klt
prompt
nowarn
timeout=100
message=/boot/message
menu-scheme=wb:bw:wb:bw
image=/boot/$kernel
	label=\"$distro\"
	root=$disk
	append=\"devfs=mount splash=silent\"
	vga=791
	read-only
";
			close LILO;
			qx(mount -t devfs none $mnt/dev ; /sbin/lilo -f $mnt ; umount $mnt/dev);
		}
	}
}

# do the actual install
sub do_install {
	my $quit = 0;
	while (!$quit) {
		my $list = "";
		foreach (sort keys %devs) {
			$list .= " \"\" \"$_\" ".int((512*$devs{$_}{size})/(1024*1024))."MB \"".$fsnames{$devs{$_}{type}}." (".$devs{$_}{type}.")\"" if ($devs{$_}{type} =~ /ext2/ || $devs{$_}{type} =~ /ext3/ || $devs{$_}{type} =~ /reiserfs/ || $devs{$_}{type} =~ /xfs/ || $devs{$_}{type} =~ /jfs/);
		}
		my $dev = qx($dlg --list --radiolist --width 500 --height 300 --title "$str{'INSTPART_TIT'}[$lang]" --column "" --column "$str{'INSTPART_PART'}[$lang]" --column "$str{'INSTPART_SIZE'}[$lang]" --column "$str{'INSTPART_TYPE'}[$lang]" $list || echo cancel);
		chomp($dev);
		unless ($dev =~ /cancel/ || $dev eq "") {
			my $ret = qx($dlg --warning --title "$str{'WARN_ERROR_TIT'}[$lang]" --text "$str{'INSTPART_WARN'}[$lang]\n$dev ($fsnames{$devs{$dev}{type}})" || echo cancel);
			unless ($ret =~ /cancel/) {
				my $mnt = "/tmp/livecd.inst.$$";
				my $type = $devs{$dev}{type};
				$devs{$dev}{opt} = $fsopts{$devs{$dev}{type}};
				$devs{$dev}{mount} = "/";
				qx(mkdir -p $mnt ; umount $dev ; mount -t $type $dev $mnt);
				copy_to($dev, $mnt);
				make_fstab($dev, $mnt);
				make_lilo($dev, $mnt);
				qx(umount $mnt && rm -rf $mnt);
				$ret = qx($dlg --question --title "$str{'FIN_TIT'}[$lang]" --text "$str{'FIN_STR'}[$lang]" && echo reboot);
				exec("/sbin/reboot") if ($ret =~ /reboot/);
				exit(0);
			}
		}
		else {
			$quit = 1;
		}
	}
}

# main entry point
MAIN: {
	my $in = interactive->vnew('su');

	# parse command-line options
	GetOptions(
		'lang=s'  => \$lang_str,
	);
	$lang = $langs{$lang_str};
	unless (defined($lang)) {
		my ($los, $ls) = split(/\:/, $ENV{LANGUAGE});
		$lang = $langs{$ls} || $langs{en};
	}
	print "$lang\n";
	exit(0);

	my $ret = qx(which zenity-qt 2>/dev/null || echo none);
	if ($ret =~ /none/) {
		$ret = qx(which zenity 2>/dev/null || echo none);
		die($str{'INITERR_ZEN'}[$lang]) if ($ret =~ /none/);
	}
	chomp($ret);
	$dlg = $ret;

	unless (-e "/initrd/usr/sbin/hwdetect") {
		qx($dlg --error --title "$str{'FATAL_ERROR_TIT'}[$lang]" --text "$str{'INITERR_LIVECD'}[$lang]");
		exit(1);
	}

	$ret = qx(id -u);
	chomp($ret);
	if ($ret ne "0") {
		qx($dlg --error --title "$str{'FATAL_ERROR_TIT'}[$lang]" --text "$str{'INITERR_ROOT'}[$lang]");
		exit(1);
	}

	qx($dlg --info --title "$str{'WELCOME_TIT'}[$lang]" --text "$str{'WELCOME_STR'}[$lang]");
	$ret = qx($dlg --warning --title "$str{'WARN_ERROR_TIT'}[$lang]" --text "$str{'WARNCORR_STR'}[$lang]" || echo cancel);
	exit(0) if ($ret =~ /cancel/);

	my $quit = 0;
	while (!$quit) {
		$ret = qx($dlg --list --radiolist --width 300 --height 200 --title "$str{'PROGSEL_TIT'}[$lang]" --column "" --column "$str{'PROGSEL_COL'}[$lang]" '' "$str{'PROGSEL_DD'}[$lang]" '' "$str{'PROGSEL_INST'}[$lang]" || echo quit);
		chomp($ret);
		if ($ret =~ /quit/) {
			exit(0);
		}
		elsif ($ret eq $str{'PROGSEL_DD'}[$lang]) {
			exec("/usr/sbin/diskdrake");
		}
		elsif ($ret eq $str{'PROGSEL_INST'}[$lang]) {
			read_parts;
			do_install;
		}
	}
}
