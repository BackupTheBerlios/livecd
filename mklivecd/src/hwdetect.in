#!/usr/bin/perl
#
# LiveCD hardware detection script
# Copyright (C) 2002-2003, Jaco Greeff <jaco@linuxminicd.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Adapted for mklivecd from the MiniCD (http://www.linuxminicd.org> hwdetect script
#
# $Id: hwdetect.in,v 1.13 2003/10/02 07:39:11 jaco Exp $
#

use lib qw(/usr/lib/libDrakX);

use standalone;

use common;
use modules;

use harddrake::sound;
use keyboard;
use mouse;
use Xconfig::card;
use Xconfig::default;
use Xconfig::monitor;
use Xconfig::parse;
use Xconfig::resolution_and_depth;
use Xconfig::screen;
use Xconfig::xfree;
use Xconfig::xfree4;

### global constants
my $SCRIPT_DESC    = "hardware detection";
my $SCRIPT_NAME    = "hwdetect";
my $SCRIPT_VER     = "@MKLIVECDVER@";
my $DEF_KEYBOARD   = "@DEF_KEYBOARD@";

### screen constants
my $RES_COL        = 65;
my $ESC            = "\x1B[";
my $MOVE_TO_COL    = $ESC.$RES_COL."G";
my $COLOR_GREEN    = $ESC."1;32m";
my $COLOR_RED      = $ESC."1;31m";
my $COLOR_YELLOW   = $ESC."1;33m";
my $COLOR_NORMAL   = $ESC."0;39m";

### global varibles
my $debug       = 0;
my $probe       = 0;
my @all_devices = ();
my %cmdline;

sub rmws {
	my ($str) = @_;
	if (defined($str)) {
		$str =~ s/\s+$//;
		$str =~ s/^\s+//;
	}
	else {
		$str = "";
	}
	$str;
}

sub move_up_lines {
	my ($lines) = @_;
	print $ESC.$lines."A" if (!$debug);
}

sub move_down_lines {
	my ($lines) = @_;
	while ($lines) {
		print "\n" if (!$debug);
		$lines--;
	}
}

sub print_success {
	print $MOVE_TO_COL if (!$debug);
	print "[  ";
	print $COLOR_GREEN if (!$debug);
	print "OK";
	print $COLOR_NORMAL if (!$debug);
	print "  ]\n";
}

sub print_loaded {
	print $MOVE_TO_COL if (!$debug);
	print "[";
	print $COLOR_GREEN if (!$debug);
	print "LOADED";
	print $COLOR_NORMAL if (!$debug);
	print "]\n";
}

sub print_warning {
	print $MOVE_TO_COL if (!$debug);
	print "[ ";
	print $COLOR_YELLOW if (!$debug);
	print "WARN";
	print $COLOR_NORMAL if (!$debug);
	print " ]\n";
}

sub print_failed {
	print $MOVE_TO_COL if (!$debug);
	print "[";
	print $COLOR_RED if (!$debug);
	print "FAILED";
	print $COLOR_NORMAL if (!$debug);
	print "]\n";
}

sub print_hash {
	my ($hash) = @_;
	print "<device>\n";
	foreach my $key (keys %$hash) {
		my $value = $hash->{$key};
		print "\t<$key>$value</$key>\n";
	}
	print "</device>\n";
}

sub print_device {
	my ($module, $vendor, $desc) = @_;
	print "    ";
	$vendor = rmws($vendor);
	$desc = rmws($desc);
	print $vendor unless ($vendor eq "");
	print ", " unless (($vendor eq "") || ($desc eq ""));
	print $desc;
}

sub hwdetect_init {
	select(STDOUT);
	$| = 1;
	open STDERR, '>', "/dev/null";

	open CMDLINE, "</proc/cmdline";
	%cmdline = map {
		my ($name, $value) = split(/=/);
		$name => $value || 1;
	} split(/ /, <CMDLINE>);
	close CMDLINE;

	print "($SCRIPT_NAME $SCRIPT_VER)";
	print_success();
}

sub hwdetect_deinit {
	print "Completing detection routines: ";
}

sub mount {
	my ($text, $opt, $type, $dev, $point) = @_;
	my $mounted = 0;
	my $res = 0;

	print $text;
	open MOUNTS, "</proc/mounts";
	foreach my $mount (<MOUNTS>) {
		my ($md, $mp, $mt, $mo, @me) = split(/ /, $mount);
		$mounted = 1 if ($mp eq $point);
	}
	close MOUNTS;
	$res = system("(mount $opt -t $type $dev $point) 2>/dev/null >/dev/null") if (!$mounted);
	$res ? print_failed() : print_success();
}

sub modprobe {
	my ($opt, $module) = @_;
	my $res = 1;
	$res = system("(/sbin/modprobe $opt $module) 2>/dev/null >/dev/null") unless ($probe);
	$res;
}

sub hwdetect_get_mediatype {
	my ($media_type) = @_;
	my @rets = ();
	foreach my $device (@all_devices) {
		push(@rets, $device) if ($device->{media_type} =~ /$media_type/);
	}
	@rets;
}

sub hwdetect_get_bustype {
	my ($bus_type) = @_;
	my @rets = ();
	foreach my $device (@all_devices) {
		push(@rets, $device) if ($device->{bus} =~ /$bus_type/);
	}
	@rets;
}

sub hwdetect_loadmod {
	my ($module, $vendor, $desc) = @_;
	my $done = 0;
	print_device($module, $vendor, $desc);
	unless ($module =~ /unknown/) {
		my $res = modprobe("", $module);
		$res ? $probe ? print_warning : print_failed() : print_loaded();
		$done++;
	}
	print "\n" unless($done);
}

sub read_proc_cpu {
	my (@cpus, $cpu);
	foreach (cat_("/proc/cpuinfo")) {
		if (/^processor/) { # ix86 specific
			push @cpus, $cpu if $cpu;
			$cpu = {};
		}
		/^([^\t]*).*:\s(.*)$/;
		$cpu->{$1} = $2 if $1;
	}
	push @cpus, $cpu;
	@cpus;
}

sub read_proc_mem {
	my ($mem);
	foreach (cat_("/proc/meminfo")) {
		if (/\:/) {
			/^([^\t]*).*:\s(.*)$/;
			$mem->{$1} = $2 if $1;
		}
	}
	$mem;
}

sub hwdetect_getmachine {
	print "Detecting architecture: ";
	my @probed_cpus = ();
	my $probed_mem = ();
	eval { @probed_cpus = read_proc_cpu() };
	eval { $probed_mem = read_proc_mem() };
	print scalar(@probed_cpus)." CPUs, ".rmws($probed_mem->{MemTotal})." memory found";
	scalar @probed_cpus && $probed_mem ? print_success() : print_failed();
	foreach my $cpu (@probed_cpus) {
		hwdetect_loadmod('unknown', $cpu->{vendor_id}, $cpu->{'model name'}." ".$cpu->{'cpu MHz'}."MHz ".$cpu->{'cache size'});
		print_hash($cpu) if ($debug);
	}
	if ($probed_mem) {
		hwdetect_loadmod('unknown', "Available Memory", rmws($probed_mem->{MemFree})." of ".rmws($probed_mem->{MemTotal}));
		hwdetect_loadmod('unknown', "Available Swap", rmws($probed_mem->{SwapFree})." of ".rmws($probed_mem->{SwapTotal}));
		print_hash($probed_mem) if ($debug);
	}
}

sub hwdetect_probeusb() {
	print "Probing USB controllers: ";
	# this is only for kernel 2.4, kernel 2.6 has only one usb
	# interface module (TODO: cater for 2.6 as well)
	my @modules = ('usb-uhci', 'usb-ohci');
	foreach my $module (@modules) {
		unless (modprobe("-q", $module)) {
			open MOD, ">>/etc/modules.conf";
			print MOD "probeall usb-interface $module\n" unless ($probe);
			close MOD;
		}
	}

	if (-e '/proc/bus/usb') {
		print_success();
		mount("Mounting USB filesystem: ", "-n", "usbdevfs", "none", "/proc/bus/usb");

		### load the usb modules that are not loaded automatically
		# "printer" should be in as well? (does cups stuff :(
		print "Loading base USB modules: ";
		@modules = ('mousedev', 'keybdev', 'usb-storage', 'visor');
		foreach my $module (@modules) {
			modprobe("-q", $module);
		}
		print_success();
	}
	else {
		print_failed();
	}
}

sub hwdetect_probeall {
	print "Probing devices: ";
	@all_devices = ();
	eval { detect_devices::probeSerialDevices(); };
	eval { @all_devices = detect_devices::probeall(); };
	scalar @all_devices ? print_success() : print_failed();
}

sub hwdetect_getkeyb {
	print "Selecting keyboard: ";
	my $probed_keyb = undef;
	my $probed_desc = "";
	my $req_keyb = $cmdline{'keyb'} || $DEF_KEYBOARD;
	eval { $probed_keyb = keyboard::lang2keyboard($req_keyb) and print_success(); } or print_failed();
	$probed_desc = keyboard::keyboard2text($probed_keyb);
	hwdetect_loadmod('unknown', "", $probed_desc);
	print_hash($probed_keyb) if ($debug);
	$probed_keyb;
}

sub hwdetect_getmouse {
	print "Detecting mouse: ";
	my $probed_vendor = "";
	my $probed_desc = "";
	my $device = undef;
	my $probed_mouse = undef;
	eval { $probed_mouse = mouse::detect() and print_success(); } or print_failed();
	if ($probed_mouse->{device} =~ /usbmouse/) {
		my @probed_mice = hwdetect_get_mediatype('Mouse');
		if (scalar @probed_mice) {
			$device = $probed_mice[0];
			($probed_vendor, $probed_desc) = split(/\|/, $device->{description});
		}
	}
	hwdetect_loadmod('unknown', $probed_vendor, $probed_mouse->{type}." ".$probed_mouse->{name}." ".$probed_desc);
	print_hash($probed_mouse) if ($debug);
	$probed_mouse;
}

sub hwdetect_getvideo {
	print "Detecting video cards: ";
	my @probed_cards = ();
	eval { @probed_cards = Xconfig::card::probe(); };
	print scalar(@probed_cards)." found";
	scalar @probed_cards ? print_success() : print_failed();
	my $probed_card = undef;
	foreach my $card (@probed_cards) {
		my ($probed_vendor, $probed_desc) = split(/\|/, $card->{description});
		hwdetect_loadmod('unknown', $probed_vendor, $card->{card_name});
		$probed_card = $card unless ($probed_card); # one card only :(
		print_hash($card) if ($debug);
	}
	$probed_card;
}

sub hwdetect_getmonitor {
	my ($rawX) = @_;
	print "Selecting monitor: ";
	my $probed_monitor = undef;

	# try to get a monitor via DDC
	eval { $probed_monitor = Xconfig::monitor::from_raw_X($rawX); };
	if (!$probed_monitor->{HorizSync}) {
		# just grab a good default
		my $def_monitor = undef;
		eval { $def_monitor = Xconfig::monitor::good_default_monitor(); };
		my $monitors = Xconfig::monitor::monitors();
		my %h_monitors = map {; "$_->{VendorName}|$_->{ModelName}" => $_ } @$monitors;
		$probed_monitor = $h_monitors{$def_monitor};
	}
	eval { $rawX->set_monitors($probed_monitor) and print_success(); } or print_failure();
	hwdetect_loadmod('unknown', $probed_monitor->{VendorName}, $probed_monitor->{ModelName}, 0);
	print_hash($probed_monitor) if ($debug);
	$probed_monitor;
}

sub hwdetect_getxfree {
	my $def_keyboard = hwdetect_getkeyb();
	my $def_mouse = hwdetect_getmouse();
	my $def_card = hwdetect_getvideo();
	my $rawX = Xconfig::default::configure($def_keyboard, $def_mouse);
	my $def_monitor = hwdetect_getmonitor($rawX);

	Xconfig::card::to_raw_X($def_card, $rawX);
	Xconfig::screen::configure($rawX, $def_card);
	Xconfig::resolution_and_depth::configure(undef, $rawX, $def_card, $def_monitor, 1);

	unless ($probe) {
		print "Writing X configuration: ";
    		eval { $rawX->write() and print_success(); } or print_failed();
	}
}

sub hwdetect_getsound {
	print "Detecting sound cards: ";
	my @probed_cards = ();
	eval { @probed_cards = hwdetect_get_mediatype('MULTIMEDIA_AUDIO'); };
	print scalar(@probed_cards)." found";
	scalar @probed_cards ? print_success() : print_failed();
	foreach my $card (@probed_cards) {
		my ($probed_vendor, $probed_desc) = split(/\|/, $card->{description});
		hwdetect_loadmod($card->{driver}, $probed_vendor, $probed_desc);
		print_hash($card) if ($debug);
	}
}

sub hwdetect_getnetwork {
	print "Detecting network cards: ";
	my @probed_cards = ();
	eval { @probed_cards = hwdetect_get_mediatype('NETWORK_ETHERNET'); };
	print scalar(@probed_cards)." found";
	scalar @probed_cards ? print_success() : print_failed();
	foreach my $card (@probed_cards) {
		my ($probed_vendor, $probed_desc) = split(/\|/, $card->{description});
		hwdetect_loadmod($card->{driver}, $probed_vendor, $probed_desc);
		print_hash($card) if ($debug);
	}
}

sub hwdetect_getserial {
	print "Detecting serial devices: ";
	my @probed_devices = ();
	print scalar(@probed_devices)." found";
	print " (not implemented)";
	print_warning();
}

sub hwdetect_getusb {
	print "Detecting USB devices: ";
	my @probed_devices = ();
	eval { @probed_devices = hwdetect_get_bustype('USB'); };
	my @usable_devices = ();
	foreach my $device (@probed_devices) {
		unless (($device->{media_type} =~ /^Hub/) ||
			($device->{media_type} =~ /Mouse/ ||
			($device->{description} =~ /Hub/))) {
			push(@usable_devices, $device);
		}
	}
	print scalar(@usable_devices) . " found";
	scalar @probed_devices ? print_success() : print_failed();
	foreach my $device (@usable_devices) {
		my ($probed_vendor, $probed_desc) = split(/\|/, $device->{description});
		hwdetect_loadmod($device->{driver}, $probed_vendor, $probed_desc);
		print_hash($device) if ($debug);
	}
}

sub hwdetect_all {
	foreach my $device (@all_devices) {
		print_hash($device) if ($debug);
	}
}

sub hwdetect_readconf {
	print "Reading modules configuration: ";
	modules::mergein_conf('/etc/modules.conf') if -r '/etc/modules.conf';
	print_success();
}

foreach (@ARGV) {
	if    (/^--debug/) { $debug = 1; }
	elsif (/^--probe/) { $probe = 1; }
	else  { die "ERROR: Unknown option '$_'"; }
}

hwdetect_init();
hwdetect_getmachine();
hwdetect_readconf();
hwdetect_probeusb();
hwdetect_probeall();
hwdetect_all() if ($debug);
hwdetect_getxfree();
hwdetect_getsound();
hwdetect_getnetwork();
hwdetect_getserial();
hwdetect_getusb() if -e '/proc/bus/usb/devices';
hwdetect_deinit();
