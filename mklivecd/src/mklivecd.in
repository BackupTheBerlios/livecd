#!/bin/bash
#
# LiveCD iso build script
# Copyright (C) 2002-2003, Jaco Greeff <jaco@linuxminicd.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Adapted from the MiniCD (http://www.linuxminicd.org) and mkinitrd build scripts
# The latest version of this script can be found at http://livecd.berlios.de
#
# $Id: mklivecd.in,v 1.60 2003/11/18 23:53:50 bgmilne Exp $
#

PATH=/sbin:/usr/sbin:$PATH
export PATH
VERSION="@MKLIVECDVER@"
PROGNAME="@PKGNAME@"

rootdir=/
target=""
kernel=""
verbose=""
MODULES=""
img_vers=""
builtins=""
modulefile=/etc/modules.conf
tmpdir=""
rc=0
kernel26=""
kernel=`uname -r`
modules_opt="@DEF_MODULES_OPT_PATH@"
modules="@DEF_MODULES_PATH@ @DEF_MODULES_DEP_PATH@ @DEF_SCSI_MODULES_PATH@ @DEF_SCSI_MODULES_DEP_PATH@"

excludedirs="^/[.].* ^/dev$ ^/initrd$ ^/lost+found$ ^/mnt$ ^/proc$ ^/tmp$ ^/var/lock/subsys$ ^/var/run$ ^/var/tmp$"
excludefiles="^/[.].* ^/fastboot$ /core[.][0-9][0-9]*$ .*[.]rpmnew$ .*[.]rpmsave$ /[.]bash_history$ /[.]fonts[.]cache-[0-9]$ /[.]xauth.* /[.]xsession-errors$"
cloopimg=""
LIVECDISOCLP="livecd.iso.clp"

# compression options
loopcmp="create_compressed_fs"
loopmod="drivers/block/cloop.o"
blocksize=64

# translucency options
transmod="fs/translucency.o"
withtrans=

# boot options
isokeyboard=""
isobootmsg=""
isoimage=""
bootopt=""
isobootkeymsg=""
resolution="@DEF_RESOLUTION@"
vgamode="@DEF_VGAMODE@"
bootsplash=1
fstabopt="ro,noauto"

# iso details
isoappid=""
isovolid=""
isoprepid=""
isopubid=""

# behaviour
homedir=""

printusage () {
	echo "
Usage:
   `basename $0` [options] <livecd-image>

General Options:
   --help                      Display this message
   --version                   Display version information

Image generation:
   --verbose                   Be verbose in output
   --root=<rootdir>            Root directory of the live filesystem to use as
                               the image for the LiveCD (default: /)
   --tmp=<tmpdir>              Name of the diirectory to be used for temporary
                               storage (default: /tmp)
   --cloop=<image>             Name of the saved compressed image. When an image
                               by this name is found, it will not be re-created
                               or overwritten, rather the existing image will be
                               re-used, i.e. the compressed image is not
                               re-built.
   --nofile=<ex1>[,][...]      Excludes files from the final image. (Also see
                               the --nodir option for a full description)
   --nodir=<ex1>[,][...]       Excludes directories from the final image.
                               Patterns passed to this option (as with the
                               --nofile option) should be valid in a grep(1)
                               search, e.g. --nodir=^/home/jaco,^/root/.mcop
                               will exclude both the /home/jaco and /root/.mcop
                               directories from the final LiveCD.
   --kernel=<kernel>           Kernel to use as default for the LiveCD image.
                               (default: $kernel)
   --lowmem                    Utilise the disk as temporary storage for iso
                               images. (default: off)
   --final                     Strip extra lines from the scripts on the initrd,
                               and optimise the LiveCD for production (no
                               debugging) use. (default: off)
   --experimental              Enable experimental LiveCD feautures. Currently
                               this option enables kernel translucency support
                               (default: off)

Compression options:
   --blocksize=<size>          Compression blocksize in K (default: 64)
   --looptype=<cloop|bzloop>   Create a cloop or bzloop image. The bzloop option
                               is utilising the experimental bzloop kernel
                               module. bzloop should not be considdered as
                               stable and might have unintended side-effects on
                               the created LiveCD. (default: cloop)

Boot options:
   --bootopt=<opt>[,<opt>]     List of comma-seperated extra options to add to
                               the kernel boot command-line.
   --bootmsg=<msg>             Use 'msg' as the isolinux boot message
   --bootkey=<key>,<msg>       Display 'msg' on key 'key' from isolinux
   --bootimg=<img>             Use 'img' (LSS format) as the isolinux background
                               display image
   --mdkboot                   Use the Mandrake boot image extension to display
                               the boot message (default: off)
   --keyboard=<mapping>        Specify a different keyboard layout as default
                               for the LiveCD (default: @DEF_KEYBOARD@)
   --resolution=<res>          Specify the resolution for the framebuffer output
                               device (default: @DEF_RESOLUTION@)
   --splash=<yes|no>[,<theme>] Create the LiveCD with bootsplash support if
                               available on the root filesystem, optionally use
                               the specified bootsplash theme (default: yes)
   --fstab=<options>           Override the default options for the fstab on the
                               LiveCD. Options are one or more of 'auto' and
                               'rw', for example '--fstab=rw,auto' will
                               automatically mount all detected partitions rw.

ISO Image options:
   --isoextrafiles=<path>      Add the files in 'path' to the root of the LiveCD
                               ISO image
   --application=<id>          Use the specified iso application ID, as '-A'
                               option to mkisofs
   --volumeid=<id>             Use the specified iso volume ID, as a '-V' option
                               to mkisofs
   --preparer=<prep>           Use the specified preparer ID, as a '-p' option
                               to mkisofs
   --publisher=<pub>           Use the specified publisher ID, as a '-P' option
                               to mkisofs

Behaviour:
   --usbhome                   Use USB memory stick devices as a persistent home
                               when available/connected on bootup.

Examples:
    `basename $0` --nodir=^/usr/src/RPM,^/root/tmp livecd.iso
    `basename $0` --blocksize=224 --bootopt=splash=silent livecd.iso
" >&2
	exit 1
}

printversion() {
	echo "
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
" >&2
	exit 0
}

### do a shell command
do_cmd() {
	stripped=`echo $* | tr -d "\t"`
	[ -n "$verbose" ] && echo "+ $stripped"
	if [ -n "$verbose" ]; then
		eval "$*" || exit
	else
		(eval "$*") 2>&1 >/dev/null || exit
	fi
}

do_cp() {
	do_cmd "cp $1 $2"
}

do_cp_strip() {
	if [ -n "$final" ]; then
		do_cmd "cat $1 | \
			sed -e 's/^#[^!].*//;s/^#$//;s/^[ ].*//' | \
			tr -d \"\t\" | grep -v ^$ >$2"
	else
		do_cp $@
	fi
}

check_kernel_26() {
	local -i major minor

	major=$(expr "$1" : '\([^.]\+\)\..*')
	minor=$(expr "$1" : '[^.]\+\.\([^.]\+\)\..*')

	if [ $major -ge 3 -o $major -eq 2 -a $minor -ge 5 ]; then
		kernel26=yes
		modulefile=/etc/modprobe.conf
		splash=""
	fi
}

is_good_fs() {
	local parttype= tmpname=
	local dir=$1
	[[ -d $dir ]] || return 1
	[[ -w $dir ]] || return 1
	[[ $dir == */ ]] && dir=${dir%/}
	parttype=$(awk "{if (\$2 == \""$dir"\") print \$3 }" /proc/mounts)

	while tmpname=${dir%/*} && [[ -z $parttype ]];do
		[[ -z $tmpname ]] && tmpname=/
		parttype=$(awk "{if (\$2 == \""$tmpname"\") print \$3 }" /proc/mounts)
		dir=$tmpname
	done

	case $parttype in
		nfs|tmpfs) return 1;;
		*) return 0;
	esac
}

is_dietlibc_arch() {
	if [ -n "`uname -m | grep '\(i.86\|x86_64\)'`" ]; then return 0; fi
	return 1
}

### generate actual initrd image
create_initrdimg() {
	### create initrd
	echo "* Creating initrd structure..." >&2
	do_cmd "mkdir -p $INITRDDIR/{bin,dev,etc/livecd/hwdetect,lib/modules,proc,sbin,usr/{bin,sbin}}"
	do_cmd "mkdir -p $INITRDDIR/{cdrom,loopfs,ramfs}"
	if is_dietlibc_arch; then
		if [[ -n "$kernel26" ]]; then
			do_cp /sbin/insmod-25-DIET $INITRDDIR/sbin/insmod
		else
			do_cp /sbin/insmod-DIET $INITRDDIR/sbin/insmod
		fi
		else
		if [[ -n "$kernel26" ]]; then
			do_cp /sbin/insmod.static-25 $INITRDDIR/sbin/insmod
		else
			do_cp /sbin/insmod.static $INITRDDIR/sbin/insmod
		fi
	fi
	do_cp /usr/bin/busybox $INITRDDIR/bin/busybox
	do_cp_strip /usr/share/mklivecd/linuxrc $INITRDDIR/linuxrc
	do_cmd "chmod 755 $INITRDDIR/linuxrc"
	do_cp_strip /usr/sbin/hwdetect $INITRDDIR/usr/sbin/hwdetect
	do_cmd "chmod 755 $INITRDDIR/usr/sbin/hwdetect"
	do_cp_strip /usr/share/mklivecd/halt.local $INITRDDIR/sbin/halt.local
	do_cmd "chmod 755 $INITRDDIR/sbin/halt.local"

	### modules
	echo "* Copying initrd kernel modules..." >&2
	do_cmd "mkdir -p $INITRDDIR$MODULESDIR/kernel"
	modules="$loopmod $modules_opt $modules"
	[ -n "$withtrans" ] && modules="$modules $transmod"
	for m in $modules; do
		mod=`basename $m`
		modpath=${rootdir}lib/modules/$kernel/kernel/$m
		if [ -f $modpath ]; then
			do_cp ${modpath} $INITRDDIR/$MODULESDIR/kernel/$mod
		else
			modpath=${modpath}.gz
			if [ ! -f $modpath ]; then
				modopt=
				for o in $modules_opt; do
					[ "$o" == "$m" ] && modopt=1
				done
				if [ -z "$modopt" ]; then
					echo "ERROR: unable to find kernel module $m" >&2
					exit 1
				fi
			else
				do_cmd "gzip -dc ${modpath} >$INITRDDIR$MODULESDIR/kernel/$mod"
			fi
		fi
	done
	do_cmd ":> $INITRDDIR$modulefile"
	if [ `uname -r` == "$kernel" ]; then
		do_cmd "depmod -av --basedir $INITRDDIR --config $INITRDDIR$modulefile"
	else
		do_cp ${rootdir}lib/modules/$kernel/modules.* $INITRDDIR/$MODULESDIR/
	fi

	### devices
	do_cmd "mknod $INITRDDIR/dev/initrd b 1 250"
	do_cmd "mknod $INITRDDIR/dev/null c 1 3"
	do_cmd "mknod $INITRDDIR/dev/systty c 4 0"
	for i in 1 2 3 4; do
		do_cmd "mknod $INITRDDIR/dev/tty$i c 4 $i"
	done

	### compressed image
	echo "* Creating compressed initrd image..." >&2
	IMAGESIZE=`du -ks $INITRDDIR | awk '{print $1}'`
	IMAGESIZE=$[IMAGESIZE+250] # some extra initial scratchpad space
	INODES=1250                # some extra inodes since we are not doing /dev anymore
	for i in `find $INITRDDIR`; do
		INODES=$[INODES + 1];
	done
	# we are using devfs and on some installs this pushes up the
	# inode count too high, resulting in "out-of-space" errors
	#for i in `find /dev`; do
	#	INODES=$[INODES + 1];
	#done
	IMAGESIZE=$[IMAGESIZE + INODES / 10]  # 10 inodes needs 1k
	[ -n "$verbose" ] && echo "+ Creating filesystem with size ${IMAGESIZE}KB and $INODES inodes"
	do_cmd "dd if=/dev/zero of=$INITRD bs=1k count=$IMAGESIZE 2> /dev/null"
	do_cmd "mke2fs -q -m 0 -F -N $INODES -s 1 $INITRD"
	do_cmd "mount -o loop -t ext2 $INITRD $INITRDMNT"
	do_cmd "rm -rf $INITRDMNT/lost+found"
	do_cmd "(cd $INITRDDIR; tar cf - .) | (cd $INITRDMNT; tar xf -)"
	do_cmd "umount $INITRDMNT"
	do_cmd  "(cd $ISOLINUXDIR ; gzip -9 initrd)"
	if [ -n "$bootsplash" ]; then
		echo "* Creating bootsplash image..." >&2
		if [ -x ${rootdir}usr/share/bootsplash/scripts/make-boot-splash ]; then
			do_cmd "(mv -f $ISOLINUXDIR/initrd.gz ${rootdir}tmp/; \
		        	chroot ${rootdir} /usr/share/bootsplash/scripts/make-boot-splash /tmp/initrd.gz ${resolution}; \
				mv -f ${rootdir}tmp/initrd.gz $ISOLINUXDIR)"
		else
			echo "WARNING: '${rootdir}usr/share/bootsplash/scripts/make-boot-splash' does not exist. Creating initrd image without bootsplash" >&2
		fi
	fi
}

### create the compressed iso image
create_cloop() {
	echo "* Creating compressed loop image..." >&2
	if [ -f "$cloopimg" ]; then
		do_cmd "ln $cloopimg $LIVECDCLOOPDIR/$LIVECDISOCLP"
	else
		# handle excluded dirs
		do_cmd ":> $EXCLUDELIST"
		if [ ! -z "$excludedirs" ]; then
			PATTERNS=""
			for e in $excludedirs; do
				if [ -z "$PATTERNS" ]; then
					PATTERNS="$e"
				else
					PATTERNS="$PATTERNS
$e"
				fi
			done
			do_cmd "( find $rootdir -type d 2>/dev/null |sed -e 's,^$rootdir,/,g'| grep '$PATTERNS' | sed 's,^/,$rootdir,' >>$EXCLUDELIST)"
		fi

		# handle excluded files
		if [ ! -z "$excludefiles" ]; then
			PATTERNS=""
			for e in $excludefiles; do
				if [ -z "$PATTERNS" ]; then
					PATTERNS="$e"
				else
					PATTERNS="$PATTERNS
$e"
				fi
			done
			do_cmd "(find $rootdir -type f 2>/dev/null |sed -e 's,^$rootdir,/,g'| grep '$PATTERNS' | sed 's,^/,$rootdir,' >>$EXCLUDELIST)"
		fi

		# create the cloop image
		if [ -z `which $loopcmp` ]; then
			echo "ERROR: '$loopcmp' does not exist on your machine. You need to install an updated version of the cloop-utils package." >&2
			exit 1
		fi
		if [ -z `which mkisofs` ]; then
			echo "ERROR: 'mkisofs' does not exist on your machine. You need to install the mkisofs package." >&2
			exit 1
		fi
		REALSIZE=$[$blocksize*1024]
		MKISOCMD="nice -n 19 mkisofs -R -exclude-list $EXCLUDELIST -hide-rr-moved -cache-inodes -no-bak -pad $verbose $verbose $rootdir"
		[ -z "$verbose" ] && MKISOCMD="$MKISOCMD 2>/dev/null"
		if [ -n "$lowmem" ]; then
			do_cmd "$MKISOCMD >$TMPISO"
			CMD="$loopcmp $TMPISO $REALSIZE >$LIVECDCLOOPDIR/$LIVECDISOCLP"
			[ -z "$verbose" ] && CMD="$CMD 2>/dev/null"
			do_cmd "$CMD"
			do_cmd "rm -rf $TMPISO"
		else
			CMD="$MKISOCMD | $loopcmp - $REALSIZE >$LIVECDCLOOPDIR/$LIVECDISOCLP"
			[ -z "$verbose" ] && CMD="$CMD 2>/dev/null"
			do_cmd "$CMD"
		fi
		[ -n "$cloopimg" ] && do_cmd "ln $LIVECDCLOOPDIR/$LIVECDISOCLP $cloopimg"
	fi
}

### install isolinux
create_isolinux() {
	echo "* Creating isolinux image..." >&2
	isolinuxbin="/usr/lib/syslinux/isolinux.bin"
	[ -n "$isographic" ] && isolinuxbin="/usr/lib/syslinux/isolinux-graphic.bin"
	if [ ! -f $isolinuxbin ]; then
		echo "ERROR: '$isolinuxbin' does not exist on your machine. You need to install the syslinux package." >&2
		exit 1
	else
		do_cp $isolinuxbin $ISOLINUXDIR/isolinux.bin
	fi
	if [ ! -f ${rootdir}boot/vmlinuz-$kernel ]; then
		echo "ERROR: The kernel '${rootdir}boot/vmlinuz-$kernel' does not exist on your machine." >&2
		exit 1
	else
		do_cp ${rootdir}boot/vmlinuz-$kernel $ISOLINUXDIR/vmlinuz
	fi
	[ -n "$isobootmsg" ] && do_cp $isobootmsg $ISOLINUXDIR/livecd.msg
	if [ -n "$isoimage" ]; then
		[ ! -f $ISOLINUXDIR/livecd.msg ] && echo -n "" >$ISOLINUXDIR/livecd.msg
		do_cmd "echo -e '\\030livecd.lss' >>$ISOLINUXDIR/livecd.msg"
		do_cp $isoimage $ISOLINUXDIR/livecd.lss
	fi
	# everything generated via echo since we put in some of our variables on the
	# various command-lines
	do_cmd "echo 'default livecd' >$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo 'prompt  1' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo 'timeout 950' >>$ISOLINUXDIR/isolinux.cfg"
	[ -f $ISOLINUXDIR/livecd.msg ] && do_cmd "echo 'display livecd.msg' >>$ISOLINUXDIR/isolinux.cfg"
	keymsg=""
	if [ -n "$isobootkeymsg" ]; then
		for l in $isobootkeymsg; do
			key=`echo $l | awk -F',' '{ print $1 }'`
			msg=`echo $l | awk -F',' '{ print $2 }'`
			do_cp $msg $ISOLINUXDIR/livecd_$key.msg
			do_cmd "echo '$key livecd_$key.msg' >>$ISOLINUXDIR/isolinux.cfg"
		done
	fi
	do_cmd "echo '' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo 'label livecd' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo '    kernel vmlinuz' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo '    append livecd=livecd initrd=initrd.gz devfs=mount fastboot=yes ramdisk_size=32000 root=/dev/rd/3 vga=$vgamode automatic=method:cdrom $isokeyboard $bootopt $homedir fstab=$fstabopt' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo '' >>$ISOLINUXDIR/isolinux.cfg"
	if [ -z "$final" ]; then
		do_cmd "echo 'label initrd' >>$ISOLINUXDIR/isolinux.cfg"
		do_cmd "echo '    kernel vmlinuz' >>$ISOLINUXDIR/isolinux.cfg"
		do_cmd "echo '    append livecd=initrd initrd=initrd.gz devfs=mount fastboot=yes ramdisk_size=32000 root=/dev/rd/3 vga=$vgamode automatic=method:cdrom $isokeyboard $bootopt $homedir fstab=$fstabopt' >>$ISOLINUXDIR/isolinux.cfg"
		do_cmd "echo '' >>$ISOLINUXDIR/isolinux.cfg"
	fi
	do_cmd "echo 'label memtest' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo '    kernel memtest' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "echo '' >>$ISOLINUXDIR/isolinux.cfg"
	do_cmd "dd if=/dev/zero of=$ISOLINUXDIR/boot.cat bs=1k count=2 2> /dev/null"
}

### create the final iso image
create_liveiso() {
	echo "* Creating final iso image..." >&2
	DISTRO=`gawk -F' ' '{ print $1 " " $2 }' $rootdir/etc/mandrake-release`
	VERSION=`gawk -F' ' '{ print $4 " " $5 }' $rootdir/etc/mandrake-release`
	VERSION_DATE=`date --utc`
	[ -z "$isoappid" ] && isoappid="$VERSION $VERSION_DATE"
	[ -z "$isovolid" ] && isovolid="$DISTRO LiveCD"
	CMD="nice -n 19 mkisofs -pad -l -R -J ${isoextrafiles:+-f} $verbose \
		-V '$isovolid' -A '$isoappid' -p '$isoprepid' -P '$isopubid' \
		-b isolinux/isolinux.bin -c isolinux/boot.cat \
		-hide-rr-moved -no-emul-boot -boot-load-size 4 -boot-info-table \
		-o $target $LIVECDDIR $isoextrafiles"
	[ -z "$verbose" ] && CMD="$CMD 2>/dev/null"
	do_cmd "$CMD"
}

check_theme() {
	[ -z "$theme" ] && return 0
	if [ -x ${rootdir}usr/share/bootsplash/scripts/switch-themes ]; then
		current_theme="`chroot ${rootdir} /usr/share/bootsplash/scripts/switch-themes -c`"
		current_theme="${current_theme#*: }"
		if [ "$theme" != "$current_theme" ]
		then
			# Is it available?
			have_requested_theme=
			for i in `chroot ${rootdir} /usr/share/bootsplash/scripts/switch-themes -l|awk '{if ($1!="Available") print $1}'`
			do
				[ "$i" == "$theme" ] && have_requested_theme=1 || :
			done
			if [ -z "$have_requested_theme" ]
			then
				echo "ERROR: The specified bootsplash theme, '$theme', is not available" >&2
				exit 1
			fi

			#We have the theme, so change it
			chroot ${rootdir} /usr/share/bootsplash/scripts/switch-themes "$theme"
		fi
	else
		echo "ERROR: '${rootdir}usr/share/bootsplash/scripts/switch-themes' does not exist. Cannot adhere to '--theme' option." >&2
		exit 1
	fi
}

restore_theme() {
	[ -z "$theme" ] && return 0
	if [ "$theme" != "$current_theme" ]
	then
		chroot ${rootdir} /usr/share/bootsplash/scripts/switch-themes "$current_theme"
	fi
}


echo "$PROGNAME, version $VERSION, http://livecd.berlios.de" >&2
echo "Copyright (C) 2002-2003, Jaco Greeff <jaco@linuxminicd.org>" >&2
while [ $# -gt 0 ]; do
	case $1 in
		--exclude*|--rootdir*|--tmpdir*|--translucency*|--iso-*|--theme*)
			echo "ERROR: The $1 option has been removed. Please use \"`basename $0` --help\" for a list of valid options." >&2
			exit 1
			;;

		--cloop*)
			if echo $1 | grep '=' >/dev/null ; then
				cloopimg="${1#--cloop=}"
			else
				cloopimg=$2
				shift
			fi
			;;

		--nodir*)
			if echo $1 | grep '=' >/dev/null ; then
				excludes="${1#--nodir=}"
			else
				excludes=$2
				shift
			fi
			for e in `echo $excludes | sed -e 's/,/ /g'`; do
				excludedirs="$excludedirs $e"
			done
			;;

		--nofile*)
			if echo $1 | grep '=' >/dev/null ; then
				excludes="${1#--nofile=}"
			else
				excludes=$2
				shift
			fi
			for e in `echo $excludes | sed -e 's/,/ /g'`; do
				excludefiles="$excludefiles $e"
			done
			;;

		--blocksize*)
			if echo $1 | grep '=' >/dev/null ; then
				blocksize="${1#--blocksize=}"
			else
				blocksize=$2
				shift
			fi
			;;

		--kernel*)
			if echo $1 | grep '=' >/dev/null ; then
				kernel="${1#--kernel=}"
			else
				kernel=$2
				shift
			fi
			;;

		--tmp*)
			if echo $1 | grep '=' >/dev/null ; then
				tmpdir="${1#--tmp=}"
			else
				tmpdir=$2
				shift
			fi
			;;

		--root*)
			if echo $1 | grep '=' >/dev/null ; then
				rootdir="${1#--root=}"
			else
				rootdir=$2
				shift
			fi
			;;

		--looptype*)
			if echo $1 | grep '=' >/dev/null ; then
				loopmod="${1#--looptype=}"
			else
				loopmod=$2
				shift
			fi
			if [ "$loopmod" == "cloop" ]; then
				LIVECDISOCLP="livecd.iso.clp"
				loopcmp="create_compressed_fs"
				loopmod="drivers/block/cloop.o"
			else
				if [ "$loopmod" == "bzloop" ]; then
					LIVECDISOCLP="livecd.iso.bzlp"
					loopcmp="create_bzfs"
					loopmod="drivers/block/bzloop.o"
				else
					echo "ERROR: You need to specify either bzloop or cloop with the '--looptype' option" >&2
					exit 1
				fi
			fi
			;;

		--lowmem)
			lowmem=1
			;;

		--final)
			final=1
			;;

		--experimental)
			withtrans=1
			;;

		--usbhome)
			homedir="home=usb"
			;;

		--splash*)
			if echo $1 | grep '=' >/dev/null ; then
				cl="${1#--splash=}"
			else
				cl=$2
				shift
			fi
			yn=`echo $cl | awk -F',' '{ print $1 }'`
			theme=`echo $cl | awk -F',' '{ print $2 }'`
			if [ "$yn" == "yes" ]; then
				bootsplash=1
			else
				bootsplash=
				theme=
			fi
			;;

		--keyboard*)
			if echo $1 | grep '=' >/dev/null ; then
				mapping="${1#--keyboard=}"
			else
				mapping=$2
				shift
			fi
			isokeyboard="keyb=$mapping"
			;;

		--resolution*)
			if echo $1 | grep '=' >/dev/null ; then
				resolution="${1#--resolution=}"
			else
				resolution=$2
				shift
			fi
			case $resolution in
				640*)
					vgamode=785
					;;
				800*)
					vgamode=788
					;;
				1024*)
					vgamode=791
					;;
				1280*)
					vgamode=794
					;;
				1600*)
					vgamode=797
					;;
				*)
					echo "ERROR: Invalid resolution '$resolution' specified with '--resolution' option" >&2
					echo "       Valid resolutions are: ">&2
					echo "            640x480" >&2
					echo "            800x600" >&2
					echo "           1024x768" >&2
					echo "          1280x1024" >&2
					echo "          1600x1200" >&2
					exit 1
					;;
			esac
			;;

		--bootopt*)
			if echo $1 | grep '=' >/dev/null ; then
				opts="${1#--bootopt=}"
			else
				opts=$2
				shift
			fi
			for o in `echo $opts | sed -e 's/,/ /g'`; do
				bootopt="$bootopt $o"
			done
			;;

		--bootmsg*)
			if echo $1 | grep '=' >/dev/null ; then
				isobootmsg="${1#--bootmsg=}"
			else
				isobootmsg=$2
				shift
			fi
			if [ ! -f "$isobootmsg" ]; then
				echo "ERROR: The specified boot message, '$isobootmsg' could not be found." >&2
				exit 1
			fi
			;;

		--bootkey*)
			if echo $1 | grep '=' >/dev/null ; then
				isobootkey="${1#--bootkey=}"
			else
				isobootkey=$2
				shift
			fi
			key=`echo $isobootkey | awk -F',' '{ print $1 }'`
			msg=`echo $isobootkey | awk -F',' '{ print $2 }'`
			if [ -z "$key" -o -z "$msg" ]; then
				echo "ERROR: You need to specify both the key and message for the '--iso-bootkey' parameter." >&2
				exit 1
			fi
			if [ ! -f "$msg" ]; then
				echo "ERROR: The specified boot message, '$msg' could not be found." >&2
				#exit 1
			fi
			isobootkeymsg="$isobootkeymsg $isobootkey"
			;;

		--mdkboot)
			isographic=1
			;;

		--bootimg*)
			if echo $1 | grep '=' >/dev/null ; then
				isoimage="${1#--bootimg=}"
			else
				isoimage=$2
				shift
			fi
			if [ ! -f "$isoimage" ]; then
				echo "ERROR: The specified boot graphic, '$isoimage' could not be found." >&2
				exit 1
			fi
			;;

		--isoextrafiles*)
			if echo $1 | grep '=' >/dev/null ; then
				isoextrafiles="${1#--isoextrafiles=}"
			else
				isoextrafiles="$2"
				shift
			fi
			if [ ! -e "$isoextrafiles" ]
			then
				echo "ERROR: Extra ISO files directory $isoextrafiles could not be found." >&2
				exit 1
			fi
			;;

		--application*)
			if echo $1 | grep '=' >/dev/null ; then
				isoappid="${1#--application=}"
			else
				isoappid=$2
				shift
			fi
			;;

		--volumeid*)
			if echo $1 | grep '=' >/dev/null ; then
				isovolid="${1#--volumeid=}"
			else
				isovolid=$2
				shift
			fi
			;;

		--preparer*)
			if echo $1 | grep '=' >/dev/null ; then
				isoprepid="${1#--preparer=}"
			else
				isoprepid=$2
				shift
			fi
			;;

		--publisher*)
			if echo $1 | grep '=' >/dev/null ; then
				isopubid="${1#--publisher=}"
			else
				isopubid=$2
				shift
			fi
			;;

		--fstab*)
			if echo $1 | grep '=' >/dev/null ; then
				fstabopt="${1#--fstab=}"
			else
				fstabopt=$2
				shift
			fi
			;;

		--version)
			printversion
			;;

		-h|--help)
			printusage
			;;

		-v|--verbose)
			verbose="-v"
			;;

		-*)
			echo "ERROR: Unknown command-line option '$1'. Try '`basename $0` --help' for valid options." >&2
			exit 1
			;;

		*)
			if [ -z "$target" ]; then
				target="$1"
			else
				printusage
			fi
			;;
	esac
	shift
done

### do we have the correct iso options?
if [ -n "$isographic" ]; then
	if [ -n "$isoimage" ]; then
		echo "ERROR: You cannot specify the '--iso-graphic' and '--iso-bgimage' options together." >&2
		exit 1
	fi
	if [ -z "$isobootmsg" ]; then
		echo "ERROR: You should specify the '--iso-bootmsg' option in conjunction with the '--iso-graphic' option/" >&2
		exit 1
	fi
fi

### do we have correct theme options?
if [ -n "$theme" ]; then
	if [ -z "$bootsplash" ]; then
		echo "ERROR: The '--theme' option can only be used with bootsplash enabled ('--splash') enabled." >&2
		exit 1
	fi
fi

### do we have target?
[ -z "$target" ] && usage

### are we root?
if [ `id -u` != "0" ]; then
	echo "ERROR: You need to be root to execute this program." >&2
	exit
fi

### check our passed parameters
[ -z "$kernel" ] && kernel=`uname -r`
[ -n "$verbose" ] && echo "+ Using $kernel as boot kernel"
check_kernel_26 "$kernel"
[[ -n $tmpdir ]] && { is_good_fs $tmpdir || tmpdir= ;} #command-line
if [[ -z $tmpdir ]]; then
	if is_good_fs /tmp; then
		tmpdir=/tmp
	elif is_good_fs $TMPDIR; then
		tmpdir=$TMPDIR
	elif is_good_fs /var/tmp; then
		tmpdir=/var/tmp
	elif is_good_fs /root/tmp; then
		tmpdir=/root/tmp
	else
		echo "Cannot find a suitable tmp directory" >&2
		exit 1
	fi
fi

# fix the root directory to be uniform in "/-before" and "/-after"
rootdir=`echo $rootdir | sed 's,/$,,'`
rootdir="$rootdir/"
[ -n "$verbose" ] && echo "+ Using $rootdir as root directory."

[ -n "$verbose" ] && echo "+ Using $tmpdir as temporary directory."
if [ -z "$target" ]; then
	usage
fi

### create the temporary directories for us to use
echo "* Creating temporary directories..." >&2
do_cmd "rm -rf $tmpdir/mklivecd.*"
CLOOPDIR=`mktemp -d ${tmpdir}/mklivecd.cloop.XXXXXX`
LIVECDDIR=`mktemp -d ${tmpdir}/mklivecd.livecd.XXXXXX`
INITRDDIR=`mktemp -d ${tmpdir}/mklivecd.initrd.XXXXXX`
INITRDMNT=`mktemp -d ${tmpdir}/mklivecd.initrd.mnt.XXXXXX`
EXCLUDELIST=`mktemp ${tmpdir}/mklivecd.excludes.XXXXXX`
TMPISO=`mktemp ${tmpdir}/mklivecd.iso.XXXXXX`
MODULESDIR=/lib/modules/$kernel
ISOLINUXDIR=$LIVECDDIR/isolinux
INITRD=$ISOLINUXDIR/initrd
RCFILE=$INITRDDIR/linuxrc
LIVECDCLOOPDIR=$LIVECDDIR

### cleanup on exit, hangup, interrupt, quit, termination
trap 'rm -rf $CLOOPDIR $LIVECDDIR $INITRDDIR $INITRDMNT $EXCLUDELIST $TMPISO' 0 1 2 3 15

### create directories
if [ -z "$LIVECDDIR" -o -z "$INITRDDIR" -o -z "$INITRDMNT" -o -z "$CLOOPDIR" ]; then
    echo "ERROR: Unable to create temporary files and/or directories." >&2
    exit 1
fi
do_cmd "mkdir -p $LIVECDDIR"
do_cmd "mkdir -p $ISOLINUXDIR"
do_cmd "mkdir -p $LIVECDCLOOPDIR"
do_cmd "mkdir -p $CLOOPDIR"

check_theme
create_initrdimg
create_cloop
create_isolinux
restore_theme
create_liveiso
